package main

import "fmt"

// 型アサーション（assertions:証言、断言、述べる）
// は、インターフェースの値の基になる具体的な値を利用する手段を提供する。
// t := i.(T)
// 上記の文は、インターフェースの値 i が具体的な型Tを保持し、
// 元になるTの値を変数tに代入する事を主張する。
//（なんとなくキャストに近い。変換するのではなく、選択して、それを証言する？）
// iがTを保持していない場合（アサーションを行った型を持っていない場合）、panic（エラー）を引き起こす。

// インターフェースの値が特定の型を保持しているかをテストする為に
// 型アサーションは2つの値（基になる値をアサーションが成功したかどうかを報告するbool値）を返す事が出来る。
// t, ok := i.(T)
// インターフェースiが型Tを保持している場合、tは基となる値になり、okは真(true)のbool値になる。
// インターフェースiが型Tを保持していない場合、tは型Tのゼロ値になり、okは偽(false)になり、panicは起きない。
// この構文とmapから読み取る構文との類似点には注意が必要。

func main() {
	// 文字列の型が入ったインターフェース i
	var i interface{} = "hello"

	//インターフェースiに文字列型があるので基となる値が変数sに入る。
	s := i.(string)
	fmt.Println(s)

	//インターフェースiに文字列はあるので、文字列型のゼロ値が変数sに入り、変数okにはbool値としてtrueが入る。
	s, ok := i.(string)
	fmt.Println(s, ok)

	// インターフェースiに倍精度型はないので、倍精度型のゼロ値（0）が変数fに入り、変数okにはbool値としてfalseが入る。
	f, ok := i.(float64)
	fmt.Println(f, ok)

	//インターフェースiに倍精度型はないので、panic（エラー）になる。
	// f = i.(float64)
	// fmt.Println(f)
}
